# [Core JS] 3-1-4. 콜백 함수 호출 시 그 함수 내부에서의 this

## 요약

- 콜백 함수 내부의 this는 “누가 호출했는가”가 아니라 “누가 실행 규칙을 정했는가”에 따라 결정된다.
- 그래서 콜백에서는 this를 당연하게 믿으면 안 되고, 실행 주체의 규칙을 먼저 확인해야 한다.

## 핵심 내용

- 콜백 함수는 다른 함수(또는 메서드)에 실행 제어권을 넘긴 함수다.
- 콜백 내부의 this는 콜백을 **호출한 함수의 규칙**을 따른다.
- 별도의 지정이 없다면 함수 호출과 동일하게 동작한다.

### 핵심내용 1: 콜백 함수의 실행 주체

- 개념: 콜백 함수는 직접 호출되지 않고, 다른 함수 내부 로직에 의해 실행된다.
- 원인: 실행 시점과 방식이 콜백을 받은 함수에 의해 결정된다.
- 결과: 콜백 내부의 this는 콜백 함수 자신이 아니라, 호출 규칙을 정한 쪽에 의해 정해진다.

### 핵심내용 2: this를 지정하지 않는 콜백의 기본 동작

- 개념: setTimeout, forEach 등은 콜백 실행 시 this를 별도로 지정하지 않는다.
- 원인: 내부적으로 단순 함수 호출 형태로 콜백을 실행한다.
- 결과: 콜백 내부의 this는 전역 객체(Window 또는 global)를 가리킨다.

### 핵심내용 3: this를 지정하는 콜백의 예외

- 개념: addEventListener 같은 API는 콜백 호출 시 this를 명시적으로 바인딩한다.
- 원인: 이벤트 핸들러의 문맥에서 this가 의미를 가지도록 설계되었기 때문이다.
- 결과: 콜백 내부의 this는 이벤트가 발생한 DOM 요소를 가리킨다.

## Check Point

- 콜백 함수의 this는 “콜백 함수가 어디에 정의되었는지”와 무관하다.
- 콜백을 실행하는 함수가 this를 지정했는지 반드시 확인해야 한다.
- 동일한 콜백 함수라도 사용처에 따라 this가 달라질 수 있다.

## 언제 문제가 되는가 / 언제 쓰는가

- 실무/React: 이벤트 핸들러, setTimeout, map/forEach 내부에서 this가 예상과 다를 때 버그가 발생한다.
- 디버깅: 콜백 내부에서 this가 undefined 또는 전역 객체를 가리키는 경우, 호출 주체부터 추적해야 한다.
- 해결 방식: arrow function 사용, bind/apply/call, 또는 this를 변수에 저장(self 패턴).

## 정리

- 콜백 함수의 this는 함수 자체가 아니라, 실행 규칙을 가진 쪽이 결정.
