# [Core JS] 1-5-1. 불변 객체를 만드는 간단한 방법

## 요약

- 참조형 데이터는 “내부 프로퍼티를 바꾸는 순간” 원본까지 같이 변할 수 있으니, 변경이 필요할 땐 **원본을 수정하지 말고 복사본(새 객체)을 만들어 반환**하는 규칙이 필요.
- 이 규칙이 지켜져야 “변경 전/후 비교”, “예상 가능한 상태 예측”, “React 렌더 최적화”가 안전해짐.

## 핵심 내용

### 핵심1. 불변 객체(immutable object)란 무엇인가

- “객체를 절대 못 바꾸는 것”이 아니라, **원본 객체를 직접 수정하지 않는 사용 규칙(컨벤션)**에 가깝습니다.
- 참조형 데이터의 ‘가변’은 **객체 자체를 다른 객체로 재할당할 때가 아니라**, **내부 프로퍼티를 수정할 때** 문제가 됩니다.
  - 예: `newUser = user; newUser.name = 'Ik'` 처럼 같은 객체를 가리킨 채 프로퍼티만 바꾸면, 원본 `user`도 함께 바뀝니다.

**원인: 왜 이런 규칙이 필요해지는가**

- 함수/모듈이 “입력으로 받은 객체”를 내부에서 바꿔버리면, 호출자는 원본이 바뀔 거라고 예상치 못 합니다.
- 결과적으로 ‘변경 감지(전/후 비교)’가 깨집니다.
  - `if (user !== user2) { ... }` 같은 비교로 변경 여부를 판단하려고 해도, 같은 객체를 공유하면 비교가 성립하지 않습니다.

**결과: 해결 방향**

- “변경이 필요하면 새 객체를 만들어 반환(재할당)”으로 바꿉니다.
  - 즉, **프로퍼티를 직접 바꾸는 방식 → 복사 + 수정된 값으로 새 객체 생성**

### 핵심내용 2

**가장 간단한 구현: 복사본을 만들고 필요한 값만 바꾸기**

- 핵심.
  - **`원본을 건드리지 말고, 새 객체를 만들어 반환하라.`**

예시(의도 전달용):

```js
function changeName(user, newName) {
  // 원본 user를 바꾸지 않는다.
  // 새로운 객체 생성 후 반환
  return {
    name: newName,
    gender: user.gender,
  };
}
```

**문제(현실적인 한계)**

- 위 방식은 필드가 많아질수록 복사 비용(코드량)이 급증합니다.
- 그래서 “복사 유틸”이 필요해집니다.

### 핵심내용 3

**copyObject 같은 유틸로 ‘얕은 복사’를 표준화하기**

- `for...in`으로 프로퍼티를 순회하며 새 객체에 옮겨 담는 방식은, 규칙을 지키기 쉽게 만들어줍니다.

```js
function copyObject(target) {
  const result = {};
  for (const prop in target) {
    result[prop] = target[prop];
  }
  return result;
}

const user2 = copyObject(user);
user2.name = 'Ik';
```

**중요: 이 방식은 ‘얕은 복사’입니다**

- 값이 원시 타입이면 안전합니다.
- 하지만 프로퍼티 값이 또 객체/배열이면 “참조”가 그대로 복사되므로, 중첩 구조에서는 여전히 원본이 함께 바뀔 수 있습니다.
  - 이 지점이 다음 단계(깊은 복사/불변 업데이트 전략)로 넘어가야 하는 이유입니다.

(실무에선 보통)

- 간단한 객체: 스프레드(`{...obj}`), `Object.assign` 같은 얕은 복사
- 중첩 구조/복잡한 상태: “불변 업데이트” 규칙(필요한 레벨만 새로 만들기) 또는 전용 도구/라이브러리(예: Immer 등)

## Check Point

- “객체의 가변성”은 **객체 자체를 바꾸는 것**이 아니라 **내부 프로퍼티를 바꾸는 것**에서 발생.

## 언제 문제가 되는가 / 언제 쓰는가

- **React 상태 관리**에서 가장 자주 발생.
  - 상태 객체를 직접 mutate하면, 참조가 유지되어 `useState`/`useReducer`의 변경 감지(그리고 memoization)가 어긋나거나, 예상과 다른 렌더링/버그가 발생.
  - 반대로 불변 업데이트를 지키면 “변경 전/후 비교”가 참조 비교로 가능해져, 리렌더 최적화와 디버깅이 쉬워집니다.

## 정리

- 참조형 데이터는 변경이 필요할 때 **원본을 건드리지 말고 복사본을 만들어 새 참조로 바꿔라** 라는 규칙이 불변성의 출발점.
