# [Core JS] 2-3-1. environmentRecord & 호이스팅

## 요약

실행 컨텍스트가 생성되는 순간, environmentRecord에 식별자가 먼저 등록되기 때문에 코드 작성 순서와 달리 변수 및 함수에 접근 가능한 현상이 발생한다.  
그래서 호이스팅은 "코드가 끌어올려지는 현상"이 아니라 "실행 전 환경 정보가 먼저 구성되는 결과"임을 이해하는 것이 중요하다.

## 핵심 내용

### 핵심내용 1: environmentRecord란 무엇인가

- environmentRecord는 **현재 실행 컨텍스트 내부의 식별자 정보를 저장하는 공간**이다.
- 변수명, 함수명, 매개변수 등이 여기에 등록된다.
- 실행 컨텍스트가 생성될 때, 코드 실행 전에 먼저 구성된다.

→ 원인: 자바스크립트 엔진은 실행 전에 **식별자 충돌 방지 및 빠른 참조**를 위해 환경 정보를 선구성한다.  
→ 결과: 선언 위치와 관계없이 식별자가 이미 존재하는 것처럼 동작한다.

### 핵심내용 2: 호이스팅은 현상이 아니라 결과다

- 호이스팅은 실제로 코드가 위로 이동하는 것이 아니다.
- environmentRecord에 식별자가 **미리 기록되어 있기 때문에** 발생하는 관찰 가능한 결과다.

```js
console.log(a); // undefined
var a = 10;
```

→ 실행 시점에는 이미 `a`라는 식별자가 _존재하지만 값은 아직 할당되지 않은 상태_ 다.

### 핵심내용 3: 선언 방식에 따라 호이스팅 결과가 달라진다

- `var`: 선언과 초기화(undefined)가 함께 environmentRecord에 등록된다.
- `let`, `const`: 선언은 기록되지만 초기화되지 않아 TDZ에 놓인다.
- 함수 선언문: 함수 전체가 등록되어 호출 가능하다.
- 함수 표현식: 변수 규칙을 따른다.

→ 같은 호이스팅이라도 **선언 방식에 따라 접근 가능 여부가 달라진다.**

## Check Point

- 호이스팅은 "끌어올림"이 아니라 **"선 실행 환경 구성"의 결과다**
- environmentRecord는 실행 중 변경되는 데이터 저장소가 아니다
- var / let / const / 함수 선언문의 차이는 모두 environmentRecord 단계에서 갈린다

## 언제 문제가 되는가 / 언제 쓰는가

- 디버깅 중 "왜 undefined지?"라는 상황의 대부분이 여기서 발생한다.
- React 컴포넌트에서 변수 선언 순서를 잘못 이해하면 의도치 않은 undefined 접근이 생긴다.
- 면접에서 호이스팅을 설명할 때, environmentRecord 관점으로 설명하면 깊이가 드러난다.

## 정리

호이스팅은 실행 컨텍스트 생성 시 environmentRecord가 먼저 구성되기 때문에 발생하는 필연적인 결과다.
