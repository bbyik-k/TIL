# [Core JS] 3-1-3. 함수로서 호출할 때 그 함수 내부에서의 this

## 요약

함수를 **객체와의 연결 없이 함수로 호출하면**, this는 호출 주체를 잃고 **전역 객체(또는 strict mode에서는 undefined)** 를 가리킨다.

## 핵심 내용

### 핵심내용 1: 함수 호출에서는 호출 주체 정보가 없다

함수를 단독으로 호출하면(obj.method 형태가 아님), 자바스크립트는 이 함수를 **누가 호출했는지에 대한 객체 정보를 알 수 없다**.  
이 경우 this는 자동으로 기본값에 바인딩된다.

- non-strict mode: 전역 객체(window / global)
- strict mode: undefined

### 핵심내용 2: 메서드 내부의 내부 함수는 메서드가 아니다

메서드 안에 정의된 함수라 하더라도, 그 함수가 **점(.) 없이 호출되면 함수 호출**로 취급된다.  
즉, 함수의 선언 위치가 아니라 **호출 방식**이 this를 결정한다.

- outer는 메서드 → this = 객체
- innerFunc는 함수 → this = 전역 객체

### 핵심내용 3: 같은 함수라도 호출 방식에 따라 this는 달라진다

하나의 함수가

- 그냥 호출되면 함수 호출 this
- 객체의 프로퍼티로 호출되면 메서드 호출 this

로 동작한다.  
this는 함수의 소유자가 아니라 **호출 순간의 형태**로 결정된다.

### 핵심내용 4: 이를 보완하기 위한 패턴과 문법이 등장했다

이 설계의 불편함 때문에 다음과 같은 보완 방법들이 등장했다.

- self = this 패턴 (ES5 이전)
- call / apply / bind
- `화살표 함수`(ES6): this를 바인딩하지 않고 상위 스코프의 this를 그대로 사용

## Check Point

- 함수 내부의 this는 항상 안전한지
- 메서드 안에 있다고 해서 내부 함수의 this가 자동으로 객체를 가리키는가

## 언제 문제가 되는가 / 언제 쓰는가

- React 클래스 컴포넌트에서 메서드를 콜백으로 넘길 때 this가 깨지는 문제
- 이벤트 핸들러, setTimeout, map 콜백 내부에서 this가 예상과 달라지는 디버깅 상황
- 오래된 코드에서 self = this 패턴을 이해해야 할 때

## 정리

this는 **함수가 어디서 정의됐는지가 아니라, _어떻게 호출됐는지_ 로 결정**.
