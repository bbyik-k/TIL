# [Core JS] 3-2-1_3. 명시적으로 this를 바인딩하는 방법 (call / apply)

## 요약

- call과 apply는 **함수를 즉시 실행하면서 this를 개발자가 원하는 객체로 강제로 지정하는 방법**이다.
- 그래서 this 규칙을 외워서 추론하지 않아도, 의도를 코드로 명확히 드러낼 수 있다.

## 핵심 내용

- 포인트: `call` / `apply`의 공통점과 차이, 그리고 왜 활용되는가
- this 자동 바인딩 규칙을 깨고 **명시적으로 제어**하는 방식이라는 점이 핵심.

### 핵심내용 1: this는 원래 호출 방식에 의해 결정된다

자바스크립트에서 this는 함수가 **어떻게 호출되었는지**에 따라 동적으로 결정.

- 일반 함수 호출, 메서드 호출, 콜백 호출 등 상황에 따라 this 규칙이 달라진다.
- 코드만 보고 this를 예측하기 어렵고, 디버깅 비용이 커진다.

### 핵심내용 2: call / apply는 this를 강제로 지정한다

call과 apply는 `Function.prototype`에 정의된 메서드로, 함수를 즉시 실행하면서 첫 번째 인자로 this를 지정한다.

- 함수 호출 시 기본 this 규칙을 우회할 필요가 있을 때 사용
- 함수 내부의 this는 호출 방식과 무관하게 **첫 번째 인자로 전달한 객체**를 가리킨다.

### 핵심내용 3: call과 apply의 차이는 인자 전달 방식이다

`call(thisArg, arg1, arg2, ...)`  
`apply(thisArg, [arg1, arg2, ...])`

- 인자 개수가 동적인 경우를 지원하기 위함.
- 배열 형태의 인자를 그대로 전달해야 할 때 apply가 자연스럽다.

### 핵심내용 4: call / apply는 재사용성과 추상화를 가능하게 한다

기존 함수나 메서드를 다른 객체의 문맥에서 재사용할 수 있다.

- this가 로직과 데이터의 연결고리 역할을 하기 때문이다.
- 유사 배열 객체(arguments, NodeList 등)에 배열 메서드를 적용하거나,  
  생성자 내부에서 다른 생성자를 호출하는 패턴이 가능해진다.

## Check Point

- call / apply는 **즉시 실행**된다.
- 첫 번째 인자는 this, 나머지는 함수의 인자다.
- this 바인딩 규칙보다 **우선순위가 가장 높다**.
- 인자 전달 방식만 다르고 동작 원리는 동일하다.

## 언제 문제가 되는가 / 언제 쓰는가

- 실무 & 디버깅  
  콜백 내부에서 this가 예상과 다를 때 call/apply로 강제 지정하면 원인을 빠르게 통제할 수 있다.
- React 이전 클래스 기반 코드  
  이벤트 핸들러나 공통 로직을 다른 객체 문맥에서 재사용할 때 자주 사용되었다.
- 라이브러리 코드  
  arguments, NodeList 같은 유사 배열 객체를 배열처럼 다뤄야 할 때 핵심 도구였다.

## 정리

- call과 apply는 **this를 선언하는 기술**.
