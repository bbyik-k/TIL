# [Core JS] 1-5-2. 얕은 복사와 깊은 복사

## 요약

- 객체를 복사할 때 내부 값까지 새로 만드는지, 참조만 공유하는지에 따라 버그 가능성이 완전히 달라진다.
- 얕은 복사는 구조만 복사하고 참조를 공유하며, 깊은 복사는 내부 데이터까지 완전히 분리한다.
- 상태 관리와 예측 가능한 코드 작성을 위해 이 차이를 정확히 이해하는 것이 중요하다.

## 핵심 내용

### 핵심내용 1: 얕은 복사는 “참조의 복사”다

객체를 얕게 복사하면 객체 자체는 새로 만들어지지만, 내부의 참조형 프로퍼티는 기존 객체와 동일한 메모리 주소를 가리킨다.  
그 결과 한쪽에서 내부 값을 변경하면 다른 쪽에도 그대로 영향을 미친다.

원인: 참조형 데이터는 값이 아니라 주소가 복사되기 때문  
결과: 원본과 사본이 논리적으로 연결된 상태가 된다

### 핵심내용 2: 깊은 복사는 “데이터의 완전한 분리”다

깊은 복사는 객체 내부의 모든 프로퍼티를 재귀적으로 복사해 새로운 데이터 구조를 만든다.  
이 방식에서는 원본과 사본이 완전히 독립적으로 동작한다.

원인: 참조형 데이터를 만날 때마다 새 객체를 생성  
결과: 한쪽을 수정해도 다른 쪽에 영향이 없다

### 핵심내용 3: JSON 방식과 재귀 복사의 한계

JSON.stringify / JSON.parse 방식은 간단한 깊은 복사처럼 보이지만 함수, undefined, prototype, getter/setter 등은 모두 제거된다.  
재귀 복사는 더 안전하지만 순환 참조나 성능 문제를 고려해야 한다.

- `httpRequest`로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋음

## Check Point

- `hasOwnProperty` 메서드를 활용한 `프로토타입 체이닝`을 통해 상속된 프로퍼티를 복사하지 않게끔 할 수 있음
- `ES5`의 `getter`/`setter`를 복사하는 방법은  
  `ES6`의 `Object.getOwnPropertyDescriptor` 또는 ES2017의 `Object.getOwnPropertyDescriptors` 외에 마땅한 방법이 존재하지 않음.

> [getOwnPropertyDescriptor란?](../getOwnPropertyDescriptor.md)

## 언제 문제가 되는가 / 언제 쓰는가

- React 상태 업데이트 시 얕은 복사를 사용하면 이전 상태가 함께 변형되는 버그가 발생한다
- Redux, 불변성 기반 상태 관리에서는 깊은 복사 개념이 필수다
- API 응답 데이터를 가공할 때 원본 보존이 필요하면 깊은 복사가 필요하다

## 정리

객체 복사의 핵심은 문법이 아니라 “참조를 공유하는가, 데이터를 분리하는가”다.
