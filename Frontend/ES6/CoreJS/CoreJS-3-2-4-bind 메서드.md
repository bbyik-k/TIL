# [Core JS] 3-2-4. bind 메서드

## 요약

bind는 함수를 즉시 실행하지 않고, this와 일부 인수를 고정한 새로운 함수를 만들어 실행 시점의 this 혼란을 제거한다.

## 핵심 내용

- 포인트: this 고정, 부분 적용, 실행 시점 분리

### 핵심내용 1: bind는 this를 고정한 새 함수를 만든다

Function.prototype.bind는 기존 함수를 실행하지 않고, this와 인수를 미리 묶은 **_새로운 함수를 반환_** 한다.

- 자바스크립트의 this는 ***호출 시점에 결정***되기 때문에, 콜백이나 비동기 상황에서 쉽게 의도와 어긋난다.
- bind를 사용하면 어디서 호출되든 this가 변하지 않는 함수를 확보할 수 있다.

### 핵심내용 2: 부분 적용(partial application)을 지원한다

bind 호출 시 전달한 인수는 고정되고, 이후 호출 시 전달한 인수는 그 뒤에 이어 붙는다.

- 복적으로 동일한 인수를 넘기는 코드가 많아지면 가독성과 유지보수성이 떨어진다.
- 공통 인수를 미리 고정해 더 단순한 함수 인터페이스를 만들 수 있다.

### 핵심내용 3: call/apply와의 결정적 차이

call/apply는 즉시 실행, bind는 실행을 지연한다.

- 실행 시점을 제어해야 하는 상황(이벤트, 타이머, 콜백)에서는 즉시 실행 방식이 부적합하다.
- bind는 콜백 전달용 함수 생성에 적합하다.

### 핵심내용 4: bind로 만들어진 함수는 식별 가능하다

bind된 함수의 name에는 `bound` 접두사가 붙는다.

- 디버깅 시 원본 함수와 bind된 함수를 구분할 필요가 있다. / 구분이 원할하다.
- call/apply보다 호출 흐름 추적이 수월하다.

## Check Point

- bind는 this를 고정.
  - 이후 call/apply로도 this를 바꿀 수 없다.
- bind는 새 함수를 만든다. 원본 함수와는 ***다른 참조***다.
- 과도한 bind 사용은 코드 흐름을 숨길 수 있다.

## 언제 문제가 되는가 / 언제 쓰는가

- 실무/React: 클래스 컴포넌트에서 이벤트 핸들러 this가 깨질 때
- 디버깅: setTimeout, 이벤트 리스너, 콜백에서 this가 window로 바인딩되는 문제
- 명확한 소유 객체(this)를 유지해야 하는 API 콜백 전달 시

## 정리

bind는 this 결정 시점을 호출 시점에서 정의 시점으로 앞당기는 도구
