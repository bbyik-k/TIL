# [Core JS] 3-2-5_6. 화살표 함수의 예외사항 & 콜백 함수에서의 this

## 요약

- 화살표 함수는 this를 바인딩하지 않고, 콜백 함수는 별도의 this 전달 방식(thisArg)을 제공한다.

## 핵심 내용

### 핵심내용 1. 화살표 함수에는 this 바인딩 과정이 없다

화살표 함수는 실행 컨텍스트를 생성할 때 this를 새로 만들지 않는다.

- ES6에서 화살표 함수는 함수 자체의 this를 없애고, 상위 스코프의 this를 그대로 참조하도록 설계되었다.
- 내부 함수, 콜백, setTimeout 등에서 this가 깨지는 문제를 문법 차원에서 예방할 수 있다.

### 핵심내용 2. bind / call / apply가 필요 없는 구조가 된다

화살표 함수 내부에서는 this가 고정되어 있다.

- this 결정 시점이 호출 시점이 아니라 **선언 시점**으로 이동했기 때문이다.
- self = this 같은 우회 코드나 bind 호출이 불필요해지고, 코드 가독성이 높아진다.

### 핵심내용 3. 콜백 함수는 thisArg로 this를 명시적으로 전달할 수 있다

일부 메서드는 콜백 함수와 함께 thisArg를 인자로 받는다.

- 반복 처리 과정에서 동일한 this를 유지해야 하는 요구가 많았기 때문이다.
- forEach, map, filter 등에서 콜백 내부 this를 안정적으로 제어할 수 있다.

### 핵심내용 4. 화살표 함수와 thisArg는 역할이 다르다

기존 API, 라이브러리, 반복 메서드에서는 thisArg 패턴도 이해해야 한다.

## Check Point

- 화살표 함수는 this를 갖지 않음
- `arguments`를 통해, 정의된 함수에 매개변수가 없어도 호출시 인수 전달 가능

## 언제 문제가 되는가 / 언제 쓰는가

- 콜백 내부 this가 window로 찍힐 때 -> thisArg 또는 bind 사용 여부 점검
- forEach, map 내부에서 this를 써야 한다면 thisArg 확인
  - 현재는 화살표 함수 및 스프레드 연산자 등의 문법이 있어 편리

## 정리

- this 문제는 함수 생성방식과 호출 방식 모두 체크
