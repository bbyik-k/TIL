# React.dev-docs-11-컴포넌트를 순수하게 유지하기

[REACT 학습하기 > UI 표현하기 > 컴포넌트를 순수하게 유지하기](https://ko.react.dev/learn/keeping-components-pure)

## Goal

- 순수성이란 무엇인지 그리고 어떻게 버그를 피하도록 도울 건지 배운다.
- 렌더링 단계에서 변화를 유지하면서 컴포넌트를 순수하게 유지하는 방법을 배운다.
- 엄격 모드를 활용하여 컴포넌트의 실수를 발견하는 방법을 배운다.

## 순수성: 공식으로서의 컴포넌트

- 컴포넌트는 [**순수 함수(pure function)**](https://en.wikipedia.org/wiki/Pure_function) 처럼 동작해야 한다.
- 순수 함수의 특징:
  - 동일한 입력 → 동일한 출력
  - 외부 변수나 객체를 직접 변경하지 않음
- React 컴포넌트는 **Props, State, Context** 라는 입력에 기반해 JSX(출력)를 반환한다. = 렌더링 한다.
- 이렇게 순수성을 지켜야 React가 예측 가능한 동작을 보장하고, 디버깅이 쉬워진다.

## 사이드 이펙트: 의도하지(않은) 결과

- **사이드 이펙트(Side Effect)**: 컴포넌트 렌더링 중에 컴포넌트 외부의 상태를 변경하는 행위
  - 예: 배열을 직접 수정, 전역 변수 변경, DOM 직접 조작
- 이런 부작용은 **렌더링 결과를 예측하기 어렵게 하고 버그를 유발**한다.

> React는 `useEffect` 훅을 제공하여 **렌더링과 부작용을 명확히 분리**하도록 유도한다.

## 지역 변경: 컴포넌트의 작은 비밀

- 컴포넌트 내부에서 **지역 변수(local variable)** 를 사용하는 것은 허용된다.
- 지역 변수는 렌더링마다 초기화되므로 외부 동작에 영향을 주지 않는다.
- 예시:
  ```js
  function Double({ number }) {
    let doubled = number * 2; // 지역 연산
    return <h1>{doubled}</h1>;
  }
  ```
- 이런 경우는 순수성을 해치지 않는다.

## 사이드 이펙트를 일으킬 수 있는 지점

- 순수성을 해치는 대표적 사례:

  - 기존 배열/객체를 직접 수정 (ex. `push`, `splice`)
  - `전역 변수` 변경
  - `DOM` 조작
  - API 호출, setTimeout 등 렌더링 중 `비동기 실행`

- 대안:

  - 배열/객체는 불변성을 지켜 복사본 생성 (`map`, `filter`, `전개 연산자` 사용)
  - API 호출은 `useEffect`에서 처리
  - DOM 접근은 React `Ref`를 통해 **필요한 경우**에만 수행

- React에서, 사이드 이펙트는 보통 이벤트 핸들러에 포함됨.
  - 이벤트 핸들러는 React가 일부 작업을 수행할 때 반응하는 기능. (버튼을 클릭할 때 등)
  - 벤트 핸들러가 컴포넌트 내부에 정의되었다 하더라도 렌더링 중에는 실행되지 않음
    - 따라서, **_이벤트 핸들러는 순수할 필요가 없음._**

### React가 순수함을 신경쓴느 이유

- 컴포넌트는 다른 환경에서도 실행될 수 있음. (ex. 서버)

  - 동일한 입력에 대해 동일한 결과를 반환하기 때문에 하나의 컴포넌트는 많은 사용자 요청을 처리할 수 있음.

- 입력이 변경되지 않은 컴포넌트 렌더링을 건너뛰어 성능을 향상시킬 수 있음.

  - 순수 함수는 항상 동일한 결과를 반환하므로 캐시하기에 안전함.

- 깊은 컴포넌트 트리를 렌더링하는 도중에 일부 데이터가 변경되는 경우 React는 오래된 렌더링을 완료하는 데 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있음.
  - 순수함은 언제든지 연산을 중단하는 것을 안전하게 함.

## 요약

- 컴포넌트는 순수해야만 한다.
  - 자신의 일에 집중한다: 렌더링 전에 존재했던 객체나 변수를 변경하지 않는다.
  - 같은 입력 → 같은 출력: 항상 동일한 JSX 반환.
- 렌더링은 언제든지 발생할 수 있으므로, 서로의 렌더링 순서에 의존하지 않는다.
- 컴포넌트 입력(`Props`, `State`, `Context`)을 직접 수정하지 않는다.
  - 화면을 업데이트하려면 기존 객체를 변경하는 대신 `State`를 “**설정(setter)**”하여 React에게 알린다.
- 반환하는 JSX에서 로직을 표현하려고 노력한다.
  - “무언가를 변경”해야 할 경우 일반적으로 **이벤트 핸들러**에서 수행한다.
  - 마지막 수단으로 `useEffect`를 사용한다.
- 순수 컴포넌트 작성은 연습이 필요하지만, React 패러다임의 진가를 발휘한다.

## 인사이트

- React 컴포넌트의 순수성 개념은, React 전체 철학의 근간임!
- 렌더링은 **언제든지 재실행**될 수 있고, React는 동일한 입력에 대해 동일한 결과를 보장하는 **함수형 사고** 위에 설계되어 있다.
- 순수하지 않은 코드(배열 직접 변경, DOM 직접 조작 등)는 작은 프로젝트에서는 잘 드러나지 않지만, 규모가 커질수록 버그와 예측 불가능성을 초래할 수 있다. 실제로 프로젝트 진행 시 많이 신경 써야할 부분.
- 엄격 모드(Strict Mode)는 이런 문제를 빨리 발견하게 도와주는 중요한 도구.

### 반환하는 JSX에서 로직을 표현한다는 것은?

- UI는 입력(`Props`, `State`)의 **“순수한 함수”** 결과여야 한다.
- 조건 분기, 필터링, 포맷팅 같은 표현 로직은 컴포넌트 본문과 반환 JSX 안에서 직접 계산하는 것이 원칙이다.
- 불필요하게 `useEffect`나 별도 `state`를 만들어 동기화하려 하면 불필요한 렌더, 깜빡임, 타이밍 문제를 유발할 수 있다.
- 따라서 **렌더링은 입력 → 출력의 계산 과정**으로만 두고, 결과를 JSX로 바로 드러내는 방식이 React 패러다임에 맞다.

- 예시 (좋은 방식):
  ```jsx
  function ProductList({ products }) {
    const visible = products.filter((p) => p.stocked);
    return (
      <ul>
        {visible.map((p) => (
          <li key={p.id}>{p.name}</li>
        ))}
      </ul>
    );
  }
  ```

### “변경”은 이벤트 핸들러에서, useEffect는 마지막 수단인 이유

- 내부 상태 변경은 사용자 상호작용(클릭, 입력 등)이 발생하는 이벤트 핸들러에서 `setState`로 직접 처리하는 것이 가장 단순하고 안전하다.
- `useEffect`는 렌더링 후 실행되며, 외부 세계와의 동기화(**네트워크 요청, 구독, DOM API 호출**) 에만 사용해야 한다.
- 불필요하게 `useEffect`를 사용하면 중복 실행, `StrictMode`의 두 번 호출, 타이밍 이슈가 발생할 수 있다.
- 예시 (올바른 방식):

  ```jsx
  function Counter() {
    const [count, setCount] = useState(0);
    return <button onClick={() => setCount((c) => c + 1)}>{count}</button>;
  }
  ```

- 예시 (정당한 useEffect 사용):
  ```jsx
  function Clock() {
    const [now, setNow] = useState(new Date());
    useEffect(() => {
      const id = setInterval(() => setNow(new Date()), 1000);
      return () => clearInterval(id);
    }, []);
    return <time>{now.toLocaleTimeString()}</time>;
  }
  ```
- UI 계산은 JSX 안에서, 상태 변경은 `이벤트 핸들러`에서, 외부 세계 동기화는 `useEffect`에서.
  이 원칙을 지켜야 React 컴포넌트를 예측 가능하고 순수하게 유지할 수 있다.
