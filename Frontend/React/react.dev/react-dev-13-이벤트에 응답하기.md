bㅠ# React.dev-docs-13-이벤트에 응답하기

[REACT 학습하기 > 상호작용성 더하기 > 이벤트에 응답하기](https://ko.react.dev/learn/responding-to-events)

## Goal

React에서는 JSX에 인벤트 핸들러 추가가 가능하다.  
이벤트 핸들러는 클릭, 마우스 호버, 폼 인풋 포커스 등 사용자 상호작용에 따라 유발되는 사용자 정의 함수다.

- 이벤트 핸들러를 작성하는 여러 가지 방법
- 이벤트 처리 로직을 부모 컴포넌트에서 전달하는 방법
- 이벤트가 전파되는 방식과 이를 멈추는 방법

## 이벤트 핸들러 추가하기

- React에서는 HTML과 유사하게 `onClick`, `onChange` 등의 prop을 통해 이벤트 핸들러를 연결한다.
- 이벤트 핸들러는 함수 그 자체를 전달해야 하며, 호출 결과를 전달하면 안 된다.
- 관습적으로 handle로 시작하며 이벤트명을 이어 붙인 이벤트 핸들러 명명법이 일반적이다.
  - `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}`와 같은 경우를 자주 볼 수 있을 것이다.
    > 관습적으로 hanleFunction 형태의 함수명을 사용하였는데, 공식 docs에 기입이 되어있는 것은 처음 안 사실!

> **주의하세요!**  
> 이벤트 핸들러로 전달한 함수들은 호출이 아닌 **전달**되어야 한다.
>
> - 올바른 예: `onClick={handleClick}`
> - 잘못된 예: `onClick={handleClick()}` >  
>    </br>
>   만약 이벤트 핸들러를 인라인으로 정의하고자 한다면, 아래와 같이 익명 함수로 감싸면 된다.  
>   `onClick={() => alert('You clicked me!')`

## 이벤트 핸들러 내에서 Prop 읽기

- 이벤트 핸들러는 동일한 컴포넌트 내부에 정의되므로, 해당 컴포넌트가 받은 **props**에 접근할 수 있다.
- 이를 통해 각기 다른 데이터에 따라 동작하는 유연한 이벤트 로직을 작성할 수 있다.

## 이벤트 핸들러를 Prop으로 전달하기

- 부모 컴포넌트에서 정의된 이벤트 핸들러를 **자식 컴포넌트에 전달**할 수 있다.
- 이 패턴을 통해 하위 컴포넌트는 독립적인 UI만 담당하고, 동작은 부모 컴포넌트가 제어한다.

> **디자인 시스템**을 적용한다면 버튼과 같은 컴포넌트는 동작을 지정하지 않고 스타일만 지정하는 것이 일반적

## 이벤트 핸들러 Prop 명명하기

- React는 HTML의 이벤트 핸들러 prop(`onClick`, `onChange`)과 별개로, **사용자 정의 prop**에도 이벤트 핸들러를 전달할 수 있다.
- 이 경우 컴포넌트 목적에 맞는 이름을 사용한다. 예: `onSelect`, `onDelete`.

> **중요합니다!**  
> 이벤트 핸들러는 반드시 적절한 HTML 태그 이벤트 prop(`onClick`, `onChange`, `onSubmit` 등)에 연결해야 한다.  
> 잘못된 태그에 연결하면 이벤트가 실행되지 않는다.

## 이벤트 전파

- React 이벤트는 기본적으로 **버블링**된다. 즉, 이벤트는 가장 깊은 요소에서 시작해 상위 요소로 전파된다.
- 이벤트 객체(`event`)의 `stopPropagation()` 메서드를 사용하여 전파를 중단할 수 있다.

> **주의하세요!**  
> `onScroll`을 제외한 모든 React 이벤트는 기본적으로 전파된다.

## 전파 멈추기

- `e.stopPropagation()`를 호출하여 전파를 멈출 수 있다.

  - 이벤트가 더 이상 **bubbling** 되지 않도록 방지

### 단계별 이벤트 캡처

- React는 이벤트 버블링 외에도 **캡처링 단계**에서 이벤트를 처리할 수 있다.
  - 캡처링: 상 -> 하
  - 버블링: 하 -> 상
- `onClickCapture`와 같이 `Capture` 접미사를 붙이면 캡처링 단계에서 이벤트가 실행된다.

## 전파의 대안으로 핸들러를 전달하기

- 이벤트 전파를 차단하는 대신, 상위 컴포넌트로부터 **이벤트 핸들러를 명시적으로 전달**하는 방식을 사용할 수 있다.
- 이 방식은 이벤트 버블링을 제어하는 것보다 코드 흐름이 명확해지고, 유지보수성이 높다.

## 기본 동작 방지하기

- 일부 이벤트는 기본 브라우저 동작을 포함한다.
  - 예: `<form>`의 `submit`은 페이지 새로고침을 유발.
- 이런 경우 `event.preventDefault()`를 호출하여 기본 동작을 막을 수 있다.

`e.stopPropagation()`은 이벤트 핸들러가 상위 태그에서 실행되지 않도록 멈춘다.

`e.preventDefault()` 는 기본 브라우저 동작을 가진 일부 이벤트가 해당 기본 동작을 실행하지 않도록 방지한다.

## 이벤트 핸들러가 사이드 이펙트를 가질 수도 있나요?

- 이벤트 핸들러는 사용자의 상호작용에 따라 실행되므로, DOM 업데이트나 네트워크 요청 등 **사이드 이펙트**를 수행할 수 있다.
- 단, 렌더링 로직 자체에서는 사이드 이펙트를 포함하지 않아야 하며, 반드시 **이벤트 핸들러**나 `useEffect` 내부에서 수행해야 한다.

## 요약

- `<button>` 등의 요소에 이벤트 핸들러를 **prop으로 전달**하여 이벤트를 처리할 수 있다.
- 이벤트 핸들러는 **호출이 아닌** 함수 자체를 전달해야 한다.
  - `onClick={handleClick()}`이 아니라 `onClick={handleClick}`
- 이벤트 핸들러는 컴포넌트 내 `props`를 자유롭게 참조할 수 있다.
- 이벤트 핸들러는 부모에서 선언해 자식에게 전달 가능하다.
- 사용자 정의 이벤트 핸들러는 애플리케이션에 맞는 이름을 사용한다.
- 이벤트는 기본적으로 **상위로 전파**되며, `e.stopPropagation()`으로 차단할 수 있다.
- 브라우저 기본 동작은 `preventDefault()`로 막을 수 있다.
- 전파를 차단하는 대신 이벤트 핸들러를 명시적으로 전달하는 패턴이 유지보수성 측면에서 더 명확하다.

## 인사이트

- 이벤트 전파는 복잡한 UI에서 디버깅을 어렵게 만들 수 있으므로, 가능하다면 **명시적으로 이벤트 핸들러를 전달하는 패턴**을 우선 고려할 것.
- `stopPropagation`과 `preventDefault`, 버블링과 캡처링의 이해와 사용.
- 이벤트 핸들러는 UI 상태 업데이트와 사이드 이펙트를 안전하게 수행할 수 있는 핵심 위치다.
