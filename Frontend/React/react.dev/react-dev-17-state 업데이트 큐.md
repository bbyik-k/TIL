# React.dev-docs-17-state 업데이트 큐

[REACT 학습하기 > 상호작용성 더하기 > state 업데이트 큐](https://ko.react.dev/learn/queueing-a-series-of-state-updates)

## Goal

Statstate 변수를 설정하면 다음 렌더링이 큐에 들어가게 된다.

그러나 때에 따라 다음 렌더링을 큐에 넣기 전에, 값에 대해 여러 작업을 수행하고 싶을 때도 있을 수 있다.

이를 위해서는 React가 state 업데이트를 어떻게 배치하면 좋을지 이해하는 것이 도움이 된다.

- ”batching”이란 무엇이며 React가 여러 state 업데이트를 처리하는 방법
- 동일한 state 변수에서 여러 업데이트를 연속으로 적용하는 방법

## React state batches 업데이트

- React는 **하나의 이벤트 핸들러 내에서 발생한 모든 state 업데이트를 모아 처리**한다. 이를 **batching**이라고 한다.
- batching은 이벤트 실행이 끝날 때까지 여러 번의 `setState` 호출을 **하나의 렌더링으로 합쳐 효율성**을 높인다.
- 따라서 `setState`를 여러 번 호출하더라도, 렌더링은 이벤트 종료 이후 **한 번만** 발생한다.

## 다음 렌더링 전에 동일한 state 변수를 여러 번 업데이트하기

- 동일한 state 변수를 여러 번 업데이트하려면 **업데이터 함수(updater function)**를 사용해야 한다.
- 업데이터 함수는 이전 state를 인자로 받아, 새로운 state를 반환한다.
- 예시:

```jsx
setNumber((n) => n + 1);
setNumber((n) => n + 1);
setNumber((n) => n + 1);
// 최종적으로 state가 3 증가
```

- 값을 직접 대입`(setNumber(number + 1))`하면 모든 호출이 동일한 스냅샷을 참조하기 때문에, 원하는 결과가 나오지 않는다.

### state를 교체한 후 업데이트하면 어떻게 되나요?

> **중요합니다!**  
> `setState(5)`가 실제로는 `setState(n => 5)` 처럼 동작하지만 매개변수 `n`이 사용되지 않기 때문에, 단순 교체로 처리된다.

교체와 업데이터 함수의 차이를 이해하는 것이 중요하다:

- `setNumber(5)` → 무조건 5로 교체
- `setNumber(n => n + 1)` → 현재 `state`에 기반하여 누적 업데이트

## 업데이트 후 state를 바꾸면 어떻게 되나요?

- React는 state 업데이트를 순차적으로 큐에 넣고 실행한다.
- 각 업데이트는 이전 업데이트의 결과를 기반으로 실행된다.
- 따라서 연속적인 연산이 필요한 경우, 반드시 업데이터 함수를 사용해야 한다.

### 명명 규칙

- state setter 함수에 인자를 줄 때, 이전 `state`를 의미하는 변수명으로 `prev`, `n`, `count` 등 의미 있는 이름을 사용하면 코드 가독성이 올라간다.

## 요약

- state를 설정하더라도 기존 렌더링의 변수는 변경되지 않으며, 대신 새로운 렌더링을 요청한다.
- React는 이벤트 핸들러가 실행을 마친 후 state 업데이트를 처리한다. 이를 **_batching_** 이라고 한다.
- 하나의 이벤트에서 일부 state를 여러 번 업데이트하려면 `setNumber(n => n + 1)` 업데이터 함수를 사용할 수 있다.
  - `setState(value)`는 사실상 `setState(() => value)`와 같다. 교체인지, 누적 업데이트인지 구분해야 한다.

## 인사이트

- React의 state 동작 원리는 “스냅샷 + 큐 + 배치(batch)”라는 키워드로 이해할 수 있다.
- `setState`를 단순 값 대입으로만 생각하면 원하는 결과가 나오지 않는 경우가 많다. 특히 카운터, 토글, 누적 업데이트 로직에서 **_업데이터 함수 패턴_**이 필수적이다.
- **batching** 메커니즘은 React의 성능 최적화 핵심 중 하나다. 이벤트 내 다수의 state 업데이트를 합쳐 한 번의 렌더링만 발생시키기 때문에, 불필요한 리렌더링을 방지할 수 있다.
- 실무에서는 비동기 로직과 결합될 때 이 개념이 헷갈릴 수 있다. 따라서 동일 이벤트 내 업데이트는 업데이터 함수, 비동기 처리 후 업데이트는 주의 깊게 순서 확인이 필요하다.
