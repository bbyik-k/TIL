# React.dev-docs-31-React Effect의 생명주기

[REACT 학습하기 > 탈출구 > React Effect의 생명주기](https://ko.react.dev/learn/lifecycle-of-reactive-effects)

## Goal

effects는 컴포넌트와 다른 생명주기를 가진다.

컴포넌트는 마운트, 업데이트, 언마운트를 거치지만, effect는 **동기화를 시작(setup)** 하고 **동기화를 중지(cleanup)** 하는 두 동작만 수행한다.

props와 state가 변화함에 따라 동일한 effect가 여러 번 시작/중지될 수 있다.

린터 규칙을 통해 의존성을 올바르게 지정하면 effect가 항상 최신 props와 state와 동기화된다.

- effect의 생명주기가 컴포넌트 생명주기와 다른 점을 이해한다.
- 각 effect를 **개별 프로세스**로 사고하는 방법을 익힌다.
- effect를 다시 동기화해야 하는 시기와 이유를 파악한다.
- effect의 의존성이 **어떻게 결정되는지** 학습한다.
- “반응형 값(reactive value)”의 의미를 이해한다.
- 빈 의존성 배열의 의미를 정확히 이해한다.
- 린터가 의존성을 검사하는 방식과 한계를 파악한다.
- 린터 의견에 동의하지 않을 때의 대처 방안을 정리한다.

## effect의 생명주기

- 각 effect는 **setup → (의존성 변경 시) cleanup → setup … → cleanup(언마운트)** 의 사이클을 가진다.
- React는 **다음 effect를 실행하기 전에 이전 effect의 cleanup을 반드시 호출**한다. 이를 통해 이벤트 리스너 누수, 중복 타이머 설치 등을 방지한다.
- 동일 컴포넌트 안의 effect들은 서로 독립적으로 동작한다. 하나의 effect가 재동기화되어도 다른 effect에는 영향이 없다.

> **중요합니다!**
>
> 일부 effects는 cleanup 함수를 전혀 반환하지 않는다.  
> 이 경우에도 React는 마치 **빈 cleanup**을 반환한 것처럼 처리한다.  
> 다만 구독·타이머·외부 인스턴스 설치 등 **자원을 소유**하는 effect라면 반드시 cleanup을 구현해야 한다.

### 동기화가 두 번 이상 수행되어야 하는 이유

- **의존성 변화**로 인해 최신 상태와 동기화를 다시 수행해야 한다.
- **조건부 렌더/키 변경**으로 대상 DOM이나 외부 자원이 바뀌면 재동기화한다.
- **개발 모드 Strict Mode**에서 버그 탐지를 위해 마운트 직후 **언마운트→재마운트**가 시뮬레이션되어 setup/cleanup이 두 번 발생한다.

### React가 effect를 재동기화하는 방법

1. 의존성 비교 결과 **변경 감지**.
2. 이전 effect의 **cleanup 실행**.
3. 새 의존성 컨텍스트로 **setup 재실행**.

### effect의 관점에서 생각하기

- “컴포넌트가 마운트/업데이트/언마운트될 때…”가 아니라, **“이 effect는 무엇을 설치/해제하는가”** 로 서술한다.
- 같은 컴포넌트라도 **각 effect는 별도의 동기화 파이프라인**이다.

### React가 effect를 다시 동기화될 수 있는지 확인하는 방법

- effect 본문에서 **참조하는 모든 반응형 값**(props, state, 컨텍스트, 렌더 중 생성된 함수/객체/배열 등)을 자동으로 추론하여 의존성 배열과 대조한다(ESLint 규칙).

### React가 effect를 다시 동기화해야 한다는 것을 인식하는 방법

- 의존성 배열의 각 항목을 **지난 렌더의 값과 현재 렌더의 값**으로 비교한다(참조 동일성 기준). **다르다면 재동기화**한다.

### 각 effect는 별도의 동기화 프로세스를 나타냅니다.

- 하나의 큰 effect에 모든 동작을 몰아넣기보다, **관심사별로 분해**하여 각각의 setup/cleanup이 독립적으로 관리되도록 한다.

## 반응형 값에 “반응”하는 effect

- **반응형 값**이란 컴포넌트 본문에서 선언되고, 렌더 간에 **달라질 수 있는 값**을 의미한다. 여기에는 props, state, context 값, 그리고 렌더 중 생성되는 함수/객체/배열/클로저가 포함된다.
- effect는 이러한 값이 바뀔 때마다 **다시 동기화**되어야 한다.

### 빈 종속성이 있는 effect의 의미

- `useEffect(setup, [])`는 **마운트 시 1회 setup**하고, **언마운트 시 cleanup**한다.
- 빈 배열을 사용하려면 effect 내부에서 참조하는 값이 **불변 또는 안정(stable)** 이어야 한다. 변하는 값을 캡처하면 **stale 클로저** 문제가 발생한다.

### 컴포넌트 본문에서 선언된 모든 변수는 반응형입니다.

- 렌더 중 생성된 함수(`const fn = () => {}`), 객체/배열 리터럴, 계산된 값은 **매 렌더 새 식별자**를 갖는다. effect가 이를 참조하면 **의존성에 포함**해야 한다.
- 안정성이 필요한 경우 `useMemo`/`useCallback`으로 식별자를 **안정화**하거나, 최신 로직만 필요하면 **`useEvent`(또는 ref 동기화)** 를 사용한다.

> **전역 또는 변경할 수 있는 값이 종속성이 될 수 있나요?**  
> 전역 싱글톤이나 변경 가능한 모듈 스코프 값은 **React가 추적하지 않는 외부 상태**이다. 값이 변할 수 있고 그 변화에 반응해야 한다면,
>
> - 해당 소스가 **구독 API**를 제공한다면 **`useSyncExternalStore`** 로 구독한다.
> - 구독이 없다면 effect에서 **폴링/리스너**를 설치하고 cleanup에서 해제한다.  
>   변하지 않는 상수(예: 환경 상수)라면 의존성에 포함할 필요가 없다.

### React는 모든 반응형 값을 종속성으로 지정했는지 확인합니다.

- ESLint의 `react-hooks/exhaustive-deps` 규칙이 effect 본문을 분석하여 **누락된 의존성**을 경고한다.
- **안정 값**(예: `useState`의 `setX`, `useRef`가 반환한 ref 객체)은 다시 렌더링해도 바뀌지 않으므로 **의존성에서 생략 가능**하다.

> **중요합니다!**  
> 어떤 경우에는 컴포넌트 내부에서 값이 선언되더라도 절대 변하지 않는다는 것을 React가 알고 있다. 예: `setState` 함수, `ref` 객체는 **안정**하므로 의존성에서 생략할 수 있다. 포함하더라도 동작에는 문제가 없다.

### 다시 동기화하지 않으려는 경우 어떻게 해야 하나요?

- **최신 로직만 필요**하고 구독을 재설치하고 싶지 않다면 `useEvent`(React 19) 또는 **ref 동기화** 패턴을 사용한다.
- effect를 **분할**하여 진짜로 의존하는 값만 포함한다.
- **렌더/이벤트로 이동**: 파생 계산은 렌더로, 사용자 상호작용은 이벤트 핸들러로 옮겨 effect 의존성을 줄인다.
- **객체/함수 식별자 안정화**: `useMemo`/`useCallback`으로 불필요한 재동기화를 방지한다.

> **주의하세요!**
>
> 린터는 유용하지만 만능은 아니다.  
> 경고를 억지로 무시하기보다 **설계를 조정**하여 경고가 사라지도록 고친다. 정말 의도된 한정된 예외(예: 외부 불변 상수)에서만 예외 주석을 사용한다.

## 요약

- 컴포넌트는 마운트, 업데이트, 언마운트한다.
- 각 effect는 컴포넌트와 별도의 생명주기를 가지며, **setup & cleanup**으로 표현된다.
- effect는 사용한 **반응형 값**이 바뀔 때 **재동기화**된다.
- React는 다음 effect 실행 전 **cleanup을 먼저 호출**한다.
- 빈 의존성 배열은 “마운트 시 한 번”을 의미하되, **불변/안정 값**만 참조해야 한다.
- 린터는 effect 내부에서 사용된 반응형 값이 의존성에 포함되었는지 검사한다.
- 린터 경고는 대부분 정당하다. **의존성을 반영하도록 설계를 재구성**할 수 있다.

## 인사이트

- effect는 **동기화용 파이프라인**으로 보고, 관심사별로 분리하여 관리한다.
- “다시 실행을 막기”보다 **다시 실행되어도 안전하도록** cleanup 대칭성을 확보한다.
- 최신 로직 접근과 재구독 최소화를 동시에 원한다면 **`useEvent`/ref 동기화**를 우선한다.
- 의존성 안정화는 **목적**(재구독 방지 vs 최신성 보장)을 분명히 하고 적용한다.
- 외부 상태는 `useSyncExternalStore` 등 **공식 구독 경로**로 읽어 일관성을 보장한다.
